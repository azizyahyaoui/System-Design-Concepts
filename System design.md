# System Design

## üß© **Module 1: Introduction to System Design**

### üîç What is System Design?

**System design** is the process of defining the architecture, components, modules, interfaces, and data for a system to satisfy specific requirements. It's like planning the blueprint of a building before construction.

In software, it covers:

* How components communicate (frontend, backend, databases, APIs)
* How data flows and is processed
* How to make systems **scalable**, **reliable**, and **maintainable**

### üõ† Why Is It Important?

* **In Interviews**: Top tech companies ask system design questions to assess your architectural thinking.
* **In Real Projects**: Designing robust systems avoids technical debt and failures at scale.
* **In Team Work**: Helps communicate solutions clearly with developers, DevOps, and stakeholders.

> ‚úÖ *‚ÄúA well-designed system saves money, scales smoothly, and fails gracefully.‚Äù*

---

### üß± Key Components of a System

Here‚Äôs a high-level breakdown of what makes up a typical system:

| Component              | Role                                           |
| ---------------------- | ---------------------------------------------- |
| **Client**             | Initiates requests (e.g., browser, mobile app) |
| **Web Server**         | Handles HTTP requests and serves content       |
| **Application Server** | Runs business logic                            |
| **Database**           | Stores and retrieves data                      |
| **Cache**              | Temporary fast-access storage                  |
| **Load Balancer**      | Distributes traffic to multiple servers        |
| **Queue**              | Handles async task processing                  |
| **Storage**            | Manages large files (images, logs, backups)    |
| **Monitoring**         | Observes system health and metrics             |

---

### üñ• Basic Computer Architecture Refresher

Understanding how a computer works helps with system design at scale.

#### üî∏ Components Overview:

```
[CPU] ‚áÑ [RAM]
  ‚Üì         ‚Üì
[Cache]   [Disk (HDD/SSD)]
```

#### üìå Definitions:

* **CPU (Central Processing Unit)**: Executes instructions.
* **RAM (Random Access Memory)**: Temporary memory for active processes.
* **Cache**: Faster than RAM, stores frequently used data (L1, L2, L3).
* **Disk**: Long-term data storage (e.g., files, databases).

---

### üß† Diagram: Typical Web-Based System Architecture

```
[ Client (Browser/App) ]
          ‚Üì
   [ Load Balancer ]
    ‚Üô           ‚Üò
[ Web Server ]  [ Web Server ]
       ‚Üì             ‚Üì
  [ App Logic / Backend ]
          ‚Üì
     [ Database ]
         ‚Üï
     [ Cache ]
```

---

### üîé Real-World Analogy

Think of a **restaurant**:

* You (client) make an order (request)
* The waiter (web server) takes it to the kitchen (application logic)
* The kitchen checks the pantry (database or cache)
* If ingredients (data) are not available, it fetches from storage (disk)
* The food (response) is delivered back to you

> üéØ The goal is to keep service fast, reliable, and available even during rush hour (high traffic)!

---

### ‚úÖ Summary Checklist

| Concept                      | Covered? ‚úÖ |
| ---------------------------- | ---------- |
| What is system design?       | ‚úÖ          |
| Why is it important?         | ‚úÖ          |
| Key system components        | ‚úÖ          |
| Computer architecture basics | ‚úÖ          |
| Sample architecture diagram  | ‚úÖ          |
| Real-world analogy           | ‚úÖ          |

---

## üß† **Module 2: Core Principles of System Design**

---

### ‚öôÔ∏è What Makes a Good System?

A well-designed system should be:

| Principle        | Meaning                                            |
| ---------------- | -------------------------------------------------- |
| **Scalable**     | Can handle increased load without performance loss |
| **Reliable**     | Functions correctly even when parts fail           |
| **Maintainable** | Easy to update, debug, and extend                  |
| **Efficient**    | Uses resources (CPU, memory, network) wisely       |
| **Available**    | Ready to serve users with minimal downtime         |
| **Secure**       | Protects data and access from threats              |

> üìå These principles guide every architectural choice you make.

---

### üå©Ô∏è The Three Pillars: Moving, Storing, Transforming Data

Every system revolves around these three key actions:

1. **Moving Data**
   E.g., HTTP requests, message queues, API calls

2. **Storing Data**
   E.g., SQL, NoSQL, object storage, distributed file systems

3. **Transforming Data**
   E.g., Business logic, computations, machine learning, formatting

> Think of your system as a pipeline that moves, stores, and transforms information continuously.

---

### üß± System Design Trade-Offs

You often can‚Äôt have it all‚Äîtrade-offs are real. One major concept that frames this:

---

### üî∫ CAP Theorem

> *You can only choose 2 out of 3:*

| Component                   | Definition                                          |
| --------------------------- | --------------------------------------------------- |
| **Consistency (C)**         | All nodes see the same data at the same time        |
| **Availability (A)**        | System continues to operate even if some parts fail |
| **Partition Tolerance (P)** | System works even when network fails between nodes  |

#### Example:

* **CA (no Partition Tolerance)**: Traditional databases like SQL
* **CP (no Availability)**: Systems that prioritize consistency under network failure
* **AP (no Consistency)**: Systems like DNS or some NoSQL databases

üß† **Diagram (Simple CAP Triangle):**

```
           Consistency
            /     \
           /       \
    Partition ‚Äî‚Äî‚Äî Availability
         Tolerance
```

> ‚öñÔ∏è You must decide what trade-offs to make based on the use case.

---

### üîß Design for Failure

No system is perfect. Assume things **will** go wrong:

| Strategy                        | Purpose                                       |
| ------------------------------- | --------------------------------------------- |
| **Redundancy**                  | Backup components take over when one fails    |
| **Retry Mechanisms**            | Auto-retry failed operations                  |
| **Timeouts & Circuit Breakers** | Avoid hanging requests or cascading failure   |
| **Monitoring & Alerts**         | Detect issues before users do                 |
| **Graceful Degradation**        | Continue partially even if some services fail |

> ‚úÖ *"Hope for the best, but design for the worst."*

---

### üß† Real-World Analogy

**Think of a delivery company**:

* **Scalable**: Can hire more drivers for more orders
* **Reliable**: Still delivers even if a few vehicles break
* **Maintainable**: Routes and schedules are easy to update
* **CAP**: If GPS (network) fails, do we wait (consistency) or deliver based on the last known address (availability)?

---

### ‚úÖ Summary Checklist

| Concept                       | Covered? ‚úÖ |
| ----------------------------- | ---------- |
| Key system design principles  | ‚úÖ          |
| 3 data pillars                | ‚úÖ          |
| Trade-offs and CAP theorem    | ‚úÖ          |
| Design for failure strategies | ‚úÖ          |
| Real-world analogy            | ‚úÖ          |

---

## üåê **Module 3: Networking Basics**

---

### üß© IP Addresses (IPv4 vs IPv6)

| Property        | IPv4                       | IPv6                                      |
| --------------- | -------------------------- | ----------------------------------------- |
| Format          | 32-bit (e.g., 192.168.1.1) | 128-bit (e.g., 2001:0db8::1)              |
| Total Addresses | \~4.3 billion              | ‚âà 340 undecillion (unlimited vibes)       |
| Address Style   | Decimal, dotted            | Hexadecimal, colon-separated              |
| Example         | `192.0.2.1`                | `2001:0db8:85a3:0000:0000:8a2e:0370:7334` |

> üìå **IPv6** solves IPv4 exhaustion and is more secure and efficient in routing.

---

### üì¶ Data Packets & Internet Protocol (IP)

* **Packet = Header + Payload**
* The header carries metadata (source, destination, TTL, etc.)
* **MTU (Maximum Transmission Unit)**: max packet size (e.g., 1500 bytes in Ethernet)

üìå Fragmentation occurs if packets exceed MTU and routers split them.

---

### üîÑ Transport Layer Protocols: TCP vs UDP

| Feature     | TCP                                 | UDP                            |
| ----------- | ----------------------------------- | ------------------------------ |
| Connection  | Connection-oriented                 | Connectionless                 |
| Reliability | Ensures delivery, ordering, no loss | No guarantee (fire-and-forget) |
| Speed       | Slower                              | Faster                         |
| Use Cases   | HTTP(S), FTP, Email, SSH            | DNS, VoIP, Gaming, Streaming   |

> üß† Think of TCP like sending registered mail, and UDP like tossing postcards.

---

### üåç DNS ‚Äì Domain Name System

**Translates human-readable names to IPs**
Example: `www.google.com` ‚Üí `142.250.190.4`

#### DNS Steps:

1. Browser checks local DNS cache
2. If not found, asks OS ‚Üí Resolver ‚Üí Root ‚Üí TLD (.com) ‚Üí Authoritative Server
3. IP is returned and cached

> ‚ö° DNS caching (local, OS, ISP) boosts speed
> üõ°Ô∏è DNSSEC adds trust/authentication to DNS responses

---

### üß± Networking Infrastructure Overview

| Component      | Description                                                            |
| -------------- | ---------------------------------------------------------------------- |
| **Public IP**  | Globally routable (e.g., assigned by ISP)                              |
| **Private IP** | Local/internal use only (`192.168.x.x`, `10.x.x.x`, `172.16.x.x`)      |
| **Firewall**   | Security layer that filters traffic (stateful/stateless)               |
| **Port**       | Virtual endpoint for communication (e.g., port 80 = HTTP, 443 = HTTPS) |
| **NAT**        | Network Address Translation‚Äîmaps private IPs to public                 |

üìå **Firewalls** and **NAT** work together to allow internal networks to talk to the internet securely.

---

### üñºÔ∏è Simple Diagram: Request from Browser to Web Server

```
[Browser] 
   ‚Üì DNS Lookup
[DNS Resolver]
   ‚Üì Get IP
[Client (Private IP)] --[NAT + Firewall]--> [Internet]
   ‚Üì
[Load Balancer] ‚Üí [Web Server (Public IP)]
   ‚Üì
[Database] or Response back
```

---

### üö¶Port Number Cheat Sheet

| Protocol | Port |
| -------- | ---- |
| HTTP     | 80   |
| HTTPS    | 443  |
| SSH      | 22   |
| FTP      | 21   |
| DNS      | 53   |
| SMTP     | 25   |
| IMAP     | 143  |
| POP3     | 110  |

---

### ‚úÖ Quick Review

| Concept                 | ‚úÖ Covered? |
| ----------------------- | ---------- |
| IP addressing basics    | ‚úÖ          |
| Packets & MTU           | ‚úÖ          |
| TCP vs UDP comparison   | ‚úÖ          |
| DNS lookup process      | ‚úÖ          |
| Public/private IP, NAT  | ‚úÖ          |
| Firewall and port usage | ‚úÖ          |

---

## üç∞ **Module 4: Application Layer Protocols**

---

The **Application Layer** is where humans interact with systems. It‚Äôs the top of the OSI model (Layer 7), where actual services like browsing, emailing, chatting, and file sharing live.

---

### üåê HTTP & HTTPS ‚Äì Web Communication Basics

* **HTTP (Hypertext Transfer Protocol)**:

  * Stateless, plain-text communication
  * Follows a **request-response** model
  * Common methods: `GET`, `POST`, `PUT`, `DELETE`

* **HTTPS** = HTTP + TLS/SSL encryption

  * Ensures **data confidentiality, integrity, and authenticity**

#### Example Request:

```
GET /index.html HTTP/1.1
Host: example.com
```

#### Browser Interaction Flow:

```
Browser ‚Üí DNS ‚Üí IP ‚Üí TCP (port 443) ‚Üí TLS handshake ‚Üí HTTP(S) Request
```

> üîê HTTPS is **critical** for protecting login forms, banking, and APIs.

---

### üßÉ WebSockets ‚Äì Real-Time Web Communication

* **Full-duplex** communication over a single TCP connection.
* Unlike HTTP, it maintains a **persistent connection** between client/server.
* Useful for:

  * Chat apps (Messenger, Discord)
  * Real-time updates (stocks, game states)

#### Diagram:

```
[Client] ‚áÑ (WebSocket over TCP) ‚áÑ [Server]
```

> üí¨ Think: HTTP is a walkie-talkie. WebSockets is a phone call.

---

### üìß Email Protocols

| Protocol | Purpose           | Port         | Notes                            |
| -------- | ----------------- | ------------ | -------------------------------- |
| SMTP     | Send mail         | 25, 587, 465 | Used by outgoing mail servers    |
| IMAP     | Read from server  | 143, 993     | Keeps messages on server         |
| POP3     | Download + delete | 110, 995     | Downloads and clears local inbox |

* IMAP is **sync-friendly** (great for multiple devices)
* POP3 is old-school (offline-first)

---

### üìÅ File Transfer Protocols

| Protocol | Secure? | Notes                              |
| -------- | ------- | ---------------------------------- |
| FTP      | ‚ùå       | Plain text, not secure             |
| FTPS     | ‚úÖ       | FTP with SSL/TLS                   |
| SFTP     | ‚úÖ       | Uses SSH for secure file transfer  |
| SCP      | ‚úÖ       | Another SSH-based fast copy method |

> üöö For sensitive files, **SFTP** or **SCP** should be your go-to.

---

### üì° Real-Time Messaging Protocols

| Protocol   | Use Case                              | Notes                                    |
| ---------- | ------------------------------------- | ---------------------------------------- |
| **WebRTC** | Peer-to-peer audio/video (Zoom, Meet) | Uses ICE, STUN, TURN for NAT traversal   |
| **MQTT**   | IoT devices (low power)               | Publish/subscribe model                  |
| **AMQP**   | Enterprise messaging (RabbitMQ)       | Queued messages with delivery guarantees |

> üß† MQTT = smart lights
> üì¶ AMQP = enterprise queues

---

### üß† RPC ‚Äì Remote Procedure Call

* **RPC**: One machine calls a function on another, as if it were local
* **Common Types**:

  * **JSON-RPC**: Lightweight, used in JavaScript
  * **XML-RPC**: Older, verbose
  * **gRPC**: Google‚Äôs high-performance RPC using Protocol Buffers

#### Example:

```protobuf
rpc GetUser(GetUserRequest) returns (UserResponse);
```

> ‚öôÔ∏è Used in microservices to reduce REST overhead

---

### üß™ When to Use What?

| Protocol Type     | Best For                         |
| ----------------- | -------------------------------- |
| HTTP/HTTPS        | REST APIs, web apps              |
| WebSockets        | Live chat, real-time games       |
| Email (SMTP/IMAP) | Communication                    |
| FTP/SFTP          | Large file transfers             |
| MQTT/AMQP         | IoT, queuing systems             |
| gRPC/RPC          | Fast internal microservice calls |

---

### ‚úÖ Quick Review

| Topic                         | ‚úÖ Covered? |
| ----------------------------- | ---------- |
| HTTP vs HTTPS                 | ‚úÖ          |
| WebSockets functionality      | ‚úÖ          |
| Email protocol differences    | ‚úÖ          |
| Secure file transfer methods  | ‚úÖ          |
| Real-time messaging protocols | ‚úÖ          |
| gRPC and RPC concepts         | ‚úÖ          |

---

## üß© **Module 5: API Design**

**‚ÄúLet systems speak clearly, efficiently, and safely.‚Äù**

---

### üçΩÔ∏è What is an API?

> **API (Application Programming Interface)** is a contract between systems to exchange data in a defined format.

It enables communication between:

* Frontend ‚Üî Backend
* Microservices
* Third-party integrations (Google Maps, Stripe)

---

### üîÅ CRUD Operations & RESTful APIs

**CRUD = Create, Read, Update, Delete**

REST (Representational State Transfer) is the **most common** API style.

| Action     | HTTP Method | Endpoint Example |
| ---------- | ----------- | ---------------- |
| Create     | POST        | `/users`         |
| Read (all) | GET         | `/users`         |
| Read (one) | GET         | `/users/{id}`    |
| Update     | PUT/PATCH   | `/users/{id}`    |
| Delete     | DELETE      | `/users/{id}`    |

#### REST Features:

* **Stateless**: No session saved on server
* **Resource-oriented**: Each object (user, post) is a resource
* **JSON** or XML payloads

---

### üß† GraphQL ‚Äì A Flexible Query Language

> "Ask exactly what you want, get exactly what you need."

Developed by Facebook to solve over-fetching or under-fetching data.

#### Example Query:

```graphql
query {
  user(id: "42") {
    name
    email
    posts {
      title
    }
  }
}
```

#### GraphQL Features:

* Single endpoint (`/graphql`)
* Strongly typed schema
* Reduces bandwidth (clients pick only needed fields)

> ‚ö†Ô∏è Needs good validation & security (introspection can leak metadata)

---

### üöÄ gRPC ‚Äì Fast, Binary RPC

> Created by Google for **high-performance**, low-latency service-to-service communication.

#### Features:

* Uses **Protocol Buffers** instead of JSON (lightweight + fast)
* Supports streaming: **client, server, and bidirectional**
* Enforces contracts via `.proto` files
* Built-in support for **authentication** and **load balancing**

| Protocol | Transport | Speed | Best Use            |
| -------- | --------- | ----- | ------------------- |
| REST     | HTTP      | üê¢    | Public APIs         |
| GraphQL  | HTTP      | üêá    | Frontend-heavy apps |
| gRPC     | HTTP/2    | üöÄ    | Internal services   |

---

### üßØ Versioning APIs

Helps maintain backward compatibility when your API evolves.

| Strategy          | Example                               |
| ----------------- | ------------------------------------- |
| URI Versioning    | `/v1/users`, `/v2/users`              |
| Header Versioning | `Accept: application/vnd.app.v1+json` |
| Query Parameter   | `/users?version=1`                    |

> üîÅ Tip: Avoid breaking old clients unless **really necessary**.

---

### üßÉ Rate Limiting & CORS

* **Rate Limiting**: Protect your APIs from abuse

  * e.g., Max 1000 requests/hour per user
  * Tools: NGINX, API Gateways, Redis-based counters

* **CORS (Cross-Origin Resource Sharing)**:

  * Allows JS apps from other origins to access your API
  * Configure HTTP headers like:

    ```
    Access-Control-Allow-Origin: *
    ```

---

### üéì Best Practices

‚úÖ Use nouns in URLs (`/users`, not `/getUser`)
‚úÖ Stick to standard HTTP codes (`200 OK`, `404 Not Found`)
‚úÖ Use pagination (`?page=1&limit=10`)
‚úÖ Always validate input & sanitize output
‚úÖ Document with Swagger/OpenAPI

---

### üéØ Summary Review

| Concept                        | ‚úÖ Covered |
| ------------------------------ | ---------- |
| RESTful API design principles  | ‚úÖ         |
| CRUD operations                | ‚úÖ         |
| GraphQL structure              | ‚úÖ         |
| gRPC use cases                 | ‚úÖ         |
| API versioning strategies      | ‚úÖ         |
| Rate limiting & CORS explained | ‚úÖ         |

---

## üß≠ **Module 7: Proxy Servers and Load Balancing**

*"If caching is memory, proxies are brains with shields, and load balancers are the traffic cops."*

---

### üîÑ What is a Proxy Server?

A **proxy server** acts as an intermediary between a client and the destination server.

#### üß© Types of Proxy Servers:

| Type                  | Description                             | Example Use                   |
| --------------------- | --------------------------------------- | ----------------------------- |
| **Forward Proxy**     | Hides the client from the server        | Bypassing geo-restrictions üåç |
| **Reverse Proxy**     | Hides the server from the client        | Load balancing, caching, SSL  |
| **Transparent Proxy** | Intercepts traffic without modifying it | Schools, ISPs, workplaces üè´  |

---

### üõ°Ô∏è Why Use Proxies?

* **Security**: IP masking, rate limiting, DDOS protection üîê
* **Access Control**: Block/allow content or sites üîí
* **Anonymity**: Hide client identity üïµÔ∏è
* **Caching**: Reduce repeated requests üíæ
* **SSL Termination**: Offload HTTPS encryption from backend servers üßØ

---

### üéõÔ∏è Load Balancers ‚Äì Smart Traffic Distributors

> **Load balancers** distribute incoming traffic across multiple servers to avoid overloading any one server.

Think of it as a **traffic officer** standing at the entrance of a server farm üßë‚Äç‚úàÔ∏è.

---

### ‚öôÔ∏è Load Balancer Types

| Type                      | Description                            |
| ------------------------- | -------------------------------------- |
| **Layer 4 (Transport)**   | Operates at TCP/UDP level              |
| **Layer 7 (Application)** | Operates at HTTP level (smart routing) |

#### Examples:

* **Nginx**, **HAProxy**, **Traefik**, **AWS ELB**

---

### üîÅ Load Balancing Algorithms

| Algorithm                | How it works                                   | Use Case                       |
| ------------------------ | ---------------------------------------------- | ------------------------------ |
| **Round Robin**          | Cycles through servers                         | Equal server capacity          |
| **Least Connections**    | Sends to the server with fewest active clients | Varying loads                  |
| **IP Hash**              | Routes users to the same server based on IP    | Sticky sessions                |
| **Weighted Round Robin** | Gives more traffic to stronger servers         | Mixed server strengths         |
| **Geo-based**            | Chooses nearest server                         | Global apps (Netflix, YouTube) |

---

### ‚òÇÔ∏è Handling Failures and Redundancy

Redundancy and failover are **critical** in system design:

* **Health Checks**: Regular ping tests to backend servers ü©∫
* **Failover Mechanisms**: Reroute to healthy servers during downtime üîÅ
* **Multi-region Load Balancing**: Fall back to another data center üåç
* **Active-Passive Setup**: Backup LB/server kicks in only on failure üõë‚û°Ô∏èüü¢
* **Auto-scaling**: Dynamically adds/removes servers based on load üìà

---

### üß™ Real-Life Example

You're visiting **Amazon.com** during Black Friday:

1. Your request goes through a **reverse proxy** (Nginx).
2. The proxy handles SSL, checks for cached content.
3. If needed, the **load balancer** picks the best backend server (lowest load).
4. One server might handle cart operations, another handles product search.

Result: **Fast, reliable experience** ‚Äî even with millions online.

---

### üß† Summary Cheat Sheet

| Concept       | Description                             |
| ------------- | --------------------------------------- |
| Proxy Server  | Middleman for traffic routing           |
| Reverse Proxy | Shields backend servers                 |
| Load Balancer | Distributes traffic                     |
| L4 vs L7      | Network vs Application level            |
| Redundancy    | Backup systems to prevent downtime      |
| Health Checks | Ensure servers are alive and responsive |

---

üíæ **Module 8: Databases and Scaling**
*"Where your data breathes, grows, and sometimes screams for optimization."* üòÖ ,`ChatGpt`

---

## üóÑÔ∏è **1. Types of Databases**

### üîπ **Relational (SQL)**

* Structured data, with predefined schemas (tables, rows)
* Uses **SQL (Structured Query Language)**
* Examples: **PostgreSQL**, **MySQL**, **Oracle**, **SQL Server**
* Great for **transactions, financial systems, and consistent data**

> üîë ACID-compliant: Atomicity, Consistency, Isolation, Durability

---

### üî∏ **NoSQL (Non-relational)**

* Flexible schemas, suitable for unstructured or semi-structured data
* Types:

  * **Document-based**: MongoDB, CouchDB
  * **Key-value stores**: Redis, DynamoDB
  * **Wide-column**: Cassandra
  * **Graph DBs**: Neo4j
* Best for **scalability**, **agility**, and **large distributed systems**

> üß© BASE: Basically Available, Soft state, Eventually consistent

---

### üîπ **In-memory Databases**

* Super-fast data access, stored in RAM
* Examples: **Redis**, **Memcached**
* Use cases: Caching, session storage, real-time analytics

---

## üìê **2. Vertical vs Horizontal Scaling**

| Scaling Type   | Description                        | Example             |
| -------------- | ---------------------------------- | ------------------- |
| **Vertical**   | Add more power to the same machine | Upgrade CPU/RAM     |
| **Horizontal** | Add more machines (scale out)      | Add more DB servers |

* **Vertical scaling** is simpler but limited
* **Horizontal scaling** offers higher fault tolerance and better long-term growth

---

## üß± **3. Sharding and Replication**

### üç∞ **Sharding**

* Split the database into **smaller, manageable parts** (shards)
* Each shard holds a portion of the data
* Based on:

  * User ID
  * Region
  * Hashing

> üì¶ Like dividing a warehouse into sections by product type or region

---

### üì° **Replication**

* **Copy data** across multiple servers
* Types:

  * **Master-Slave** (Primary-Secondary)
  * **Master-Master**
  * **Read Replicas**

> üß¨ Boosts read performance and adds redundancy

---

## üîç **4. Database Performance Optimization**

* **Indexing**: Accelerate searches on columns
* **Query Optimization**: Write efficient SQL (avoid `SELECT *`)
* **Connection Pooling**: Reuse DB connections
* **Caching**: Store frequently accessed data in memory
* **Partitioning**: Divide large tables into smaller pieces

---

## üí° Real-World Analogy

Imagine Amazon‚Äôs order system:

* A **SQL DB** ensures consistent transactions for payments.
* A **NoSQL DB** handles the fast, flexible product catalog.
* **Redis** stores your shopping cart for snappy interactions.
* **Shards** distribute users across servers by region.
* **Replication** ensures you don‚Äôt lose orders during server failure.

---

## üß† Summary Cheat Sheet

| Concept      | Purpose                             |
| ------------ | ----------------------------------- |
| SQL DB       | Structured data, strong consistency |
| NoSQL DB     | Scalability, flexible schema        |
| In-memory DB | Blazing speed, temporary storage    |
| Sharding     | Data distribution for scalability   |
| Replication  | High availability, load balancing   |
| Indexing     | Fast lookups                        |
| Partitioning | Divide large datasets               |

---

ü´° **Wrap-Up: System Design Masterclass Takeaway**
*"No packet dropped, no concept left behind."*

---

### üß± **Core Concepts Recap**

| üß© Module | Key Focus                      | Highlights                                               |
| --------- | ------------------------------ | -------------------------------------------------------- |
| 1. Intro  | What & Why of System Design    | System components, architecture, real-world significance |
| 2. Core   | Design Principles & Trade-offs | Scalability, CAP Theorem, system resilience              |
| 3. Net    | Networking Basics              | TCP/UDP, IPs, DNS, TTL‚Äîyour first "ping" to architecture |
| 4. App    | Application Layer Protocols    | HTTP, WebSockets, SMTP, FTP, RPC magic                   |
| 5. API    | Designing Reliable Interfaces  | REST, gRPC, versioning, rate limiting, best practices    |
| 6. Cache  | Caching & CDN                  | Eviction policies, push vs pull CDN, speed & savings     |
| 7. Proxy  | Load Balancing & Proxy Power   | Round robin, IP hash, failovers, proxies in action       |
| 8. DB     | Databases & Scaling            | SQL vs NoSQL, sharding, replication, optimization tricks |

---

### üîë **Big Takeaways**

* üì° *Scalability isn‚Äôt just a buzzword‚Äîit‚Äôs a survival skill.*
* üîÑ *Trade-offs define architecture; perfection is a myth.*
* ‚öôÔ∏è *Modularity = maintainability = peace of mind.*
* üß† *Design for failure, cache for speed, and always plan for growth.*





